#include "LCDateTools.h"
#include "GNUstep.h"

/**
* Provides support for converting dates to strings and vice-versa.
 * The strings are structured so that lexicographic sorting orders 
 * them by date, which makes them suitable for use as field values 
 * and search terms.
 * 
 * <P>This class also helps you to limit the resolution of your dates. Do not
 * save dates with a finer resolution than you really need, as then
 * RangeQuery and PrefixQuery will require more memory and become slower.
 * 
 * <P>Compared to {@link DateField} the strings generated by the methods
 * in this class take slightly more space, unless your selected resolution
 * is set to <code>Resolution.DAY</code> or lower.
 */
@implementation NSString (LuceneKit_Document_Date)

/** convert a date to string in this format depending on resolution:
 * "%Y%m%d%H%M%S%F" (yyyyMMddHHmmssSSS) in GMT.
 */
+ (id)stringWithCalendarDate: (NSDate *)date resolution: (LCResolution)resolution
{
	NSCalendar					*curCalendar;
	NSUInteger					unitFlags;
	NSDateComponents			*dateComps;
	NSDate						*resolvedDate;

	/* Make sure date is in GMT format */
	curCalendar = [NSCalendar currentCalendar];
	[curCalendar setTimeZone: [NSTimeZone timeZoneWithAbbreviation: @"GMT"]];

	unitFlags = NSYearCalendarUnit;
	if (resolution == LCResolution_MONTH)
	{
		unitFlags = unitFlags | NSMonthCalendarUnit;
	}

	if (resolution == LCResolution_DAY)
	{
		unitFlags = unitFlags |  NSDayCalendarUnit;
	}

	if (resolution == LCResolution_HOUR)
	{
		unitFlags = unitFlags | NSHourCalendarUnit;
	}

	if (resolution == LCResolution_MINUTE)
	{
		unitFlags = unitFlags | NSMinuteCalendarUnit;
	}

	if (resolution == LCResolution_SECOND)
	{
		unitFlags = unitFlags | NSSecondCalendarUnit;
	}

	dateComps = [curCalendar components: unitFlags fromDate: date];
	resolvedDate = [curCalendar dateFromComponents: dateComps];

	return ([resolvedDate description]);
}


/**
* Converts a string produced by <code>timeToString</code> or
 * <code>dateToString</code> back to a time, represented as the
 * number of milliseconds since January 1, 1970, 00:00:00 GMT.
 * 
 * @param dateString the date string to be converted
 * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
 * @throws ParseException if <code>dateString</code> is not in the 
 *  expected format 
 */
- (NSTimeInterval)timeIntervalSince1970
{
	return [[self calendarDate] timeIntervalSince1970];
}


/* Convert a string in this format to date:
 * "%Y%m%d%H%M%S%F" (yyyyMMddHHmmssSSS) in GMT.
 */
- (NSDate *)calendarDate;
{
	NSLocale				*enUSPOSIXLocale;
	NSDateFormatter			*dateFormatter;
	NSDate					*date = nil;

	enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier: @"en_US_POSIX"];
	dateFormatter = [[NSDateFormatter alloc] init];

	[dateFormatter setTimeStyle: NSDateFormatterNoStyle];
	[dateFormatter setDateStyle: NSDateFormatterMediumStyle];
	[dateFormatter setLocale: enUSPOSIXLocale];

	/* make sure the string is in GMT format */
	[dateFormatter setTimeZone: [NSTimeZone timeZoneForSecondsFromGMT: 0]];
	[dateFormatter setLenient: NO];
	date = [dateFormatter dateFromString: self];
	[dateFormatter release];
	[enUSPOSIXLocale release];
	return (date);
}

@end



@implementation NSDate (LuceneKit_Document_Date)

/**
* Limit a date's resolution. For example, the date <code>1095767411000</code>
 * (which represents 2004-09-21 13:50:11) will be changed to 
 * <code>1093989600000</code> (2004-09-01 00:00:00) when using
 * <code>Resolution.MONTH</code>.
 * 
 * @param resolution The desired resolution of the date to be returned
 * @return the date with all values more precise than <code>resolution</code>
 *  set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT
 */
- (NSTimeInterval)timeIntervalSince1970WithResolution: (LCResolution)res
{
	return [[self dateWithResolution: res] timeIntervalSince1970];
}

/**
* Limit a date's resolution. For example, the date <code>2004-09-21 13:50:11</code>
 * will be changed to <code>2004-09-01 00:00:00</code> when using
 * <code>Resolution.MONTH</code>. 
 * 
 * @param resolution The desired resolution of the date to be returned
 * @return the date with all values more precise than <code>resolution</code>
 *  set to 0 or 1
 */
- (NSDate *)dateWithResolution: (LCResolution)resolution
{
	NSCalendar					*curCalendar;
	NSUInteger					unitFlags;
	NSDateComponents			*dateComps;
	
	/* Make sure date is in GMT format */
	curCalendar = [NSCalendar currentCalendar];
	[curCalendar setTimeZone: [NSTimeZone timeZoneWithAbbreviation: @"GMT"]];
	
	unitFlags = NSYearCalendarUnit;
	if (resolution == LCResolution_MONTH)
	{
		unitFlags = unitFlags | NSMonthCalendarUnit;
	}
	
	if (resolution == LCResolution_DAY)
	{
		unitFlags = unitFlags |  NSDayCalendarUnit;
	}
	
	if (resolution == LCResolution_HOUR)
	{
		unitFlags = unitFlags | NSHourCalendarUnit;
	}
	
	if (resolution == LCResolution_MINUTE)
	{
		unitFlags = unitFlags | NSMinuteCalendarUnit;
	}
	
	if (resolution == LCResolution_SECOND)
	{
		unitFlags = unitFlags | NSSecondCalendarUnit;
	}
	
	dateComps = [curCalendar components: unitFlags fromDate: self];
	return ([curCalendar dateFromComponents: dateComps]);
}

@end

